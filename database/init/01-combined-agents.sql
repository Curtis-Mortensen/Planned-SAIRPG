-- ============================================
-- COMBINED AGENT SCHEMAS
-- Auto-generated by combine-schemas.sh
-- DO NOT EDIT DIRECTLY - edit individual agent files
-- ============================================

-- This file is generated from individual agent schema files.
-- Each section below is sourced from a separate file in the agents/ directory.

-- Generated: 2024-12-30 (manual creation for reference)

-- ============================================
-- Source: agents/action-evaluator.sql
-- ============================================

-- ============================================
-- Agent: Action Evaluator
-- Phase: 1
-- Description: Interprets player input and determines
--              difficulty rating for the attempted action
-- ============================================

-- Stores evaluated actions with their interpretations
-- This allows players to see how their input was understood
CREATE TABLE IF NOT EXISTS evaluated_actions (
    evaluation_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id) ON DELETE CASCADE,
    
    -- Original player input (exactly as typed)
    raw_input TEXT NOT NULL,
    
    -- How the agent interpreted the action
    interpreted_action TEXT NOT NULL,
    
    -- Difficulty assessment
    difficulty VARCHAR(50) NOT NULL,  -- trivial, easy, moderate, hard, extreme
    difficulty_score INTEGER NOT NULL CHECK (difficulty_score BETWEEN 1 AND 100),
    
    -- What skills/attributes are relevant (for future stat integration)
    relevant_skills JSONB DEFAULT '[]',
    
    -- Was this a fallback interpretation?
    used_fallback BOOLEAN DEFAULT FALSE,
    
    -- LLM metadata for debugging
    llm_prompt_tokens INTEGER,
    llm_completion_tokens INTEGER,
    processing_time_ms INTEGER,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for finding evaluations by tick
CREATE INDEX IF NOT EXISTS idx_evaluated_actions_tick 
    ON evaluated_actions(tick_id);

-- Register this agent's settings schema
INSERT INTO agent_registry (agent_id, display_name, description, phase, settings_schema)
VALUES (
    'action_evaluator',
    'Action Evaluator',
    'Interprets player input and determines difficulty rating',
    1,
    '{
        "parameters": [
            {
                "id": "interpretation_strictness",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.5,
                "step": 0.1,
                "label": "Interpretation Strictness",
                "description": "How literally to interpret player input (0 = creative, 1 = strict)",
                "ui_component": "slider"
            },
            {
                "id": "default_difficulty",
                "type": "enum",
                "options": ["trivial", "easy", "moderate", "hard", "extreme"],
                "default": "moderate",
                "label": "Default Difficulty",
                "description": "Fallback difficulty when unable to assess",
                "ui_component": "dropdown"
            }
        ]
    }'::jsonb
)
ON CONFLICT (agent_id) DO UPDATE SET
    settings_schema = EXCLUDED.settings_schema,
    display_name = EXCLUDED.display_name;

-- ============================================
-- End Agent: Action Evaluator
-- ============================================

-- ============================================
-- Source: agents/probability-roll.sql
-- ============================================

-- ============================================
-- Agent: Probability Roll
-- Phase: 1
-- Description: Rolls against difficulty to determine
--              success, partial success, or failure
-- ============================================

-- Stores all rolls for transparency and replay
CREATE TABLE IF NOT EXISTS probability_rolls (
    roll_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id) ON DELETE CASCADE,
    evaluation_id UUID REFERENCES evaluated_actions(evaluation_id),
    
    -- The roll itself
    roll_value INTEGER NOT NULL CHECK (roll_value BETWEEN 1 AND 100),
    
    -- Difficulty threshold from evaluator
    difficulty_score INTEGER NOT NULL,
    
    -- Any modifiers applied
    modifiers JSONB DEFAULT '[]',  -- [{name: "tired", value: -10}, ...]
    final_threshold INTEGER NOT NULL,  -- difficulty + modifiers
    
    -- Outcome
    outcome VARCHAR(50) NOT NULL,  -- success, partial, failure
    margin INTEGER NOT NULL,  -- How much over/under threshold
    
    -- Was this a fallback roll?
    used_fallback BOOLEAN DEFAULT FALSE,
    
    -- For reproducibility
    random_seed BIGINT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for finding rolls by tick
CREATE INDEX IF NOT EXISTS idx_probability_rolls_tick 
    ON probability_rolls(tick_id);

-- Index for analytics (outcome distribution)
CREATE INDEX IF NOT EXISTS idx_probability_rolls_outcome 
    ON probability_rolls(outcome);

-- Register this agent's settings schema
INSERT INTO agent_registry (agent_id, display_name, description, phase, settings_schema)
VALUES (
    'probability_roll',
    'Probability Roll',
    'Determines success or failure based on difficulty',
    1,
    '{
        "parameters": [
            {
                "id": "use_player_stats",
                "type": "boolean",
                "default": false,
                "label": "Use Player Stats",
                "description": "Apply player stat bonuses to rolls (when stats system is implemented)",
                "ui_component": "toggle"
            },
            {
                "id": "base_difficulty_modifier",
                "type": "integer",
                "min": -20,
                "max": 20,
                "default": 0,
                "step": 5,
                "label": "Difficulty Modifier",
                "description": "Global adjustment to all difficulty checks (negative = easier)",
                "ui_component": "slider"
            },
            {
                "id": "partial_success_range",
                "type": "integer",
                "min": 5,
                "max": 25,
                "default": 15,
                "step": 5,
                "label": "Partial Success Range",
                "description": "How close to threshold counts as partial success",
                "ui_component": "slider"
            }
        ]
    }'::jsonb
)
ON CONFLICT (agent_id) DO UPDATE SET
    settings_schema = EXCLUDED.settings_schema,
    display_name = EXCLUDED.display_name;

-- ============================================
-- End Agent: Probability Roll
-- ============================================

-- ============================================
-- Source: agents/narrator.sql
-- ============================================

-- ============================================
-- Agent: Narrator
-- Phase: 1
-- Description: Generates narrative text describing
--              what happened based on action and outcome
-- ============================================

-- Stores all generated narrative segments
-- Each tick produces one narrative entry
CREATE TABLE IF NOT EXISTS narrative_segments (
    segment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id) ON DELETE CASCADE,
    roll_id UUID REFERENCES probability_rolls(roll_id),
    
    -- The narrative content
    narrative_text TEXT NOT NULL,
    
    -- Metadata about what this narrates
    narrates_action TEXT,  -- What player action this describes
    narrates_outcome VARCHAR(50),  -- success/partial/failure
    
    -- For context continuity
    previous_segment_id UUID REFERENCES narrative_segments(segment_id),
    
    -- Was this a fallback narrative?
    used_fallback BOOLEAN DEFAULT FALSE,
    
    -- Version for edits (player can edit narrative)
    version INTEGER DEFAULT 1,
    is_player_edited BOOLEAN DEFAULT FALSE,
    original_text TEXT,  -- Stores AI version if player edited
    
    -- LLM metadata
    llm_prompt_tokens INTEGER,
    llm_completion_tokens INTEGER,
    processing_time_ms INTEGER,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Full narrative transcript view (for context window)
-- This combines all segments in order for a branch
CREATE OR REPLACE VIEW narrative_transcript AS
SELECT 
    b.session_id,
    b.branch_id,
    t.tick_number,
    t.world_time,
    ns.narrative_text,
    ns.is_player_edited,
    ns.created_at
FROM narrative_segments ns
JOIN ticks t ON ns.tick_id = t.tick_id
JOIN branches b ON t.branch_id = b.branch_id
ORDER BY b.session_id, b.branch_id, t.tick_number;

-- Index for finding narrative by tick
CREATE INDEX IF NOT EXISTS idx_narrative_segments_tick 
    ON narrative_segments(tick_id);

-- Index for building transcript (by branch)
CREATE INDEX IF NOT EXISTS idx_narrative_segments_branch 
    ON narrative_segments(tick_id);

-- Register this agent's settings schema
INSERT INTO agent_registry (agent_id, display_name, description, phase, settings_schema)
VALUES (
    'narrator',
    'Story Narrator',
    'Generates narrative text describing events and outcomes',
    1,
    '{
        "parameters": [
            {
                "id": "verbosity",
                "type": "enum",
                "options": ["brief", "normal", "elaborate"],
                "default": "normal",
                "label": "Narrative Length",
                "description": "How detailed the narrative descriptions should be",
                "ui_component": "dropdown"
            },
            {
                "id": "tone",
                "type": "enum",
                "options": ["gritty", "neutral", "heroic", "comedic", "dark"],
                "default": "neutral",
                "label": "Narrative Tone",
                "description": "The overall mood and style of narration",
                "ui_component": "dropdown"
            },
            {
                "id": "include_internal_thoughts",
                "type": "boolean",
                "default": true,
                "label": "Include Character Thoughts",
                "description": "Whether to narrate the player character internal thoughts",
                "ui_component": "toggle"
            },
            {
                "id": "context_paragraphs",
                "type": "integer",
                "min": 1,
                "max": 10,
                "default": 3,
                "step": 1,
                "label": "Context Length",
                "description": "How many previous paragraphs to include for context",
                "ui_component": "slider"
            }
        ]
    }'::jsonb
)
ON CONFLICT (agent_id) DO UPDATE SET
    settings_schema = EXCLUDED.settings_schema,
    display_name = EXCLUDED.display_name;

-- ============================================
-- End Agent: Narrator
-- ============================================

-- ============================================
-- Source: agents/save-load.sql
-- ============================================

-- ============================================
-- Agent: Save/Load System
-- Phase: 1
-- Description: Manages game saves, auto-saves,
--              and state restoration
-- ============================================

-- Player-created and auto-saves
CREATE TABLE IF NOT EXISTS game_saves (
    save_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    session_id UUID NOT NULL REFERENCES sessions(session_id) ON DELETE CASCADE,
    branch_id UUID NOT NULL REFERENCES branches(branch_id),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id),
    
    -- Save metadata
    save_name VARCHAR(255) NOT NULL,
    save_type VARCHAR(50) NOT NULL,  -- manual, auto, quicksave
    
    -- Snapshot of world state at save time
    world_state_snapshot JSONB NOT NULL,
    
    -- Agent settings at save time (so loading restores settings too)
    agent_settings_snapshot JSONB,
    
    -- For save browser UI
    preview_text TEXT,  -- Last few sentences of narrative
    world_time VARCHAR(100),  -- In-game time
    play_time_seconds INTEGER,  -- Real time played
    
    -- Auto-save slot management
    auto_save_slot INTEGER,  -- 1-5 for rotating auto-saves
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Prevent duplicate auto-saves in same slot
    CONSTRAINT unique_auto_save_slot 
        UNIQUE NULLS NOT DISTINCT (session_id, auto_save_slot)
);

-- World state snapshots for faster loading
-- Created periodically (not every tick) for performance
CREATE TABLE IF NOT EXISTS world_snapshots (
    snapshot_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    session_id UUID NOT NULL REFERENCES sessions(session_id) ON DELETE CASCADE,
    branch_id UUID NOT NULL REFERENCES branches(branch_id),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id),
    
    -- Complete world state as JSON
    snapshot_data JSONB NOT NULL,
    
    -- What's included in this snapshot
    includes_narrative BOOLEAN DEFAULT TRUE,
    includes_npcs BOOLEAN DEFAULT FALSE,  -- Phase 3
    includes_locations BOOLEAN DEFAULT TRUE,
    includes_meta_events BOOLEAN DEFAULT FALSE,  -- Phase 2
    
    -- For choosing which snapshot to load from
    tick_number INTEGER NOT NULL,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for finding saves by session
CREATE INDEX IF NOT EXISTS idx_game_saves_session 
    ON game_saves(session_id, created_at DESC);

-- Index for finding auto-saves
CREATE INDEX IF NOT EXISTS idx_game_saves_auto 
    ON game_saves(session_id, save_type, auto_save_slot) 
    WHERE save_type = 'auto';

-- Index for finding snapshots for replay
CREATE INDEX IF NOT EXISTS idx_world_snapshots_branch 
    ON world_snapshots(branch_id, tick_number DESC);

-- Function to create an auto-save with rotating slots
CREATE OR REPLACE FUNCTION create_auto_save(
    p_session_id UUID,
    p_branch_id UUID,
    p_tick_id UUID,
    p_world_state JSONB,
    p_preview_text TEXT,
    p_world_time VARCHAR(100),
    p_max_slots INTEGER DEFAULT 5
)
RETURNS UUID AS $$
DECLARE
    v_next_slot INTEGER;
    v_save_id UUID;
BEGIN
    -- Find the next slot (oldest auto-save or first empty)
    SELECT COALESCE(
        (SELECT auto_save_slot FROM game_saves 
         WHERE session_id = p_session_id AND save_type = 'auto'
         ORDER BY created_at ASC LIMIT 1),
        1
    ) INTO v_next_slot;
    
    -- Wrap around if needed
    IF v_next_slot > p_max_slots THEN
        v_next_slot := 1;
    END IF;
    
    -- Delete existing save in this slot
    DELETE FROM game_saves 
    WHERE session_id = p_session_id 
      AND save_type = 'auto' 
      AND auto_save_slot = v_next_slot;
    
    -- Create new auto-save
    INSERT INTO game_saves (
        session_id, branch_id, tick_id, 
        save_name, save_type, 
        world_state_snapshot, preview_text, world_time,
        auto_save_slot
    )
    VALUES (
        p_session_id, p_branch_id, p_tick_id,
        'Auto-save ' || v_next_slot, 'auto',
        p_world_state, p_preview_text, p_world_time,
        v_next_slot
    )
    RETURNING save_id INTO v_save_id;
    
    RETURN v_save_id;
END;
$$ LANGUAGE plpgsql;

-- Register this agent's settings schema
INSERT INTO agent_registry (agent_id, display_name, description, phase, settings_schema)
VALUES (
    'save_load',
    'Save/Load System',
    'Manages game saves and state restoration',
    1,
    '{
        "parameters": [
            {
                "id": "auto_save_enabled",
                "type": "boolean",
                "default": true,
                "label": "Auto-Save Enabled",
                "description": "Automatically save after each tick",
                "ui_component": "toggle"
            },
            {
                "id": "auto_save_slots",
                "type": "integer",
                "min": 1,
                "max": 10,
                "default": 5,
                "step": 1,
                "label": "Auto-Save Slots",
                "description": "Number of rotating auto-save slots",
                "ui_component": "slider"
            },
            {
                "id": "snapshot_frequency",
                "type": "integer",
                "min": 1,
                "max": 20,
                "default": 5,
                "step": 1,
                "label": "Snapshot Frequency",
                "description": "Create full snapshot every N ticks (for faster loading)",
                "ui_component": "slider"
            }
        ]
    }'::jsonb
)
ON CONFLICT (agent_id) DO UPDATE SET
    settings_schema = EXCLUDED.settings_schema,
    display_name = EXCLUDED.display_name;

-- ============================================
-- End Agent: Save/Load System
-- ============================================

-- ============================================
-- Source: agents/meta-event-generator.sql
-- ============================================

-- ============================================
-- Agent: Meta Event Generator
-- Phase: 2
-- Description: Proposes world events that may occur
--              each tick, independent of player action
-- ============================================

-- Library of possible world events
-- These are templates that can be instantiated
CREATE TABLE IF NOT EXISTS meta_event_templates (
    template_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    session_id UUID REFERENCES sessions(session_id) ON DELETE CASCADE,
    
    -- Event definition
    event_name VARCHAR(255) NOT NULL,
    event_description TEXT NOT NULL,
    category VARCHAR(50) NOT NULL,  -- positive, negative, neutral
    
    -- Base probability (before modifiers)
    base_probability INTEGER NOT NULL CHECK (base_probability BETWEEN 1 AND 100),
    rarity VARCHAR(50) DEFAULT 'common',  -- common, uncommon, rare, epic
    
    -- When this event can trigger
    location_requirement JSONB,  -- NULL = any location, or {location_id: ...}
    time_requirement JSONB,  -- NULL = any time, or {min_hour: 0, max_hour: 12}
    prerequisite_events JSONB DEFAULT '[]',  -- Events that must have happened
    
    -- Cooldown (can't trigger twice in N ticks)
    cooldown_ticks INTEGER DEFAULT 0,
    last_triggered_tick INTEGER,
    
    -- Is this a system template or player-created?
    is_system_template BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Events proposed for a specific tick
CREATE TABLE IF NOT EXISTS proposed_events (
    proposal_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id) ON DELETE CASCADE,
    template_id UUID REFERENCES meta_event_templates(template_id),
    
    -- Event details (may be customized from template)
    event_name VARCHAR(255) NOT NULL,
    event_description TEXT NOT NULL,
    category VARCHAR(50) NOT NULL,
    
    -- Probability for this specific proposal
    calculated_probability INTEGER NOT NULL,
    modifiers_applied JSONB DEFAULT '[]',  -- What affected the probability
    
    -- Approval status (set by player-approval agent)
    status VARCHAR(50) DEFAULT 'pending',  -- pending, approved, rejected
    
    -- If triggered, what roll was made?
    trigger_roll INTEGER,
    was_triggered BOOLEAN DEFAULT FALSE,
    
    -- Was this a fallback (empty proposal)?
    used_fallback BOOLEAN DEFAULT FALSE,
    
    -- LLM metadata
    llm_prompt_tokens INTEGER,
    llm_completion_tokens INTEGER,
    processing_time_ms INTEGER,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for querying events
CREATE INDEX IF NOT EXISTS idx_meta_event_templates_session 
    ON meta_event_templates(session_id);

CREATE INDEX IF NOT EXISTS idx_meta_event_templates_category 
    ON meta_event_templates(category, rarity);

CREATE INDEX IF NOT EXISTS idx_proposed_events_tick 
    ON proposed_events(tick_id);

CREATE INDEX IF NOT EXISTS idx_proposed_events_status 
    ON proposed_events(tick_id, status);

-- Register this agent's settings schema
INSERT INTO agent_registry (agent_id, display_name, description, phase, settings_schema)
VALUES (
    'meta_event_generator',
    'World Event Generator',
    'Creates possible events that might happen in the world',
    2,
    '{
        "parameters": [
            {
                "id": "event_count",
                "type": "integer",
                "min": 4,
                "max": 20,
                "default": 8,
                "step": 1,
                "label": "Events to Generate",
                "description": "Number of possible events to propose each tick",
                "ui_component": "slider"
            },
            {
                "id": "positive_weight",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.33,
                "step": 0.05,
                "label": "Positive Event Weight",
                "description": "Likelihood of generating beneficial events",
                "ui_component": "slider"
            },
            {
                "id": "negative_weight",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.33,
                "step": 0.05,
                "label": "Negative Event Weight",
                "description": "Likelihood of generating harmful events",
                "ui_component": "slider"
            },
            {
                "id": "include_rare_events",
                "type": "boolean",
                "default": true,
                "label": "Include Rare Events",
                "description": "Whether to occasionally propose rare and epic events",
                "ui_component": "toggle"
            },
            {
                "id": "creativity",
                "type": "float",
                "min": 0.0,
                "max": 1.0,
                "default": 0.7,
                "step": 0.1,
                "label": "Creativity",
                "description": "Higher values produce more unusual events",
                "ui_component": "slider"
            }
        ]
    }'::jsonb
)
ON CONFLICT (agent_id) DO UPDATE SET
    settings_schema = EXCLUDED.settings_schema,
    display_name = EXCLUDED.display_name;

-- ============================================
-- End Agent: Meta Event Generator
-- ============================================

-- ============================================
-- Source: agents/player-approval.sql
-- ============================================

-- ============================================
-- Agent: Player Approval
-- Phase: 2
-- Description: Gates event progression on player
--              approval/rejection of proposed events
-- ============================================

-- Approval decisions history
CREATE TABLE IF NOT EXISTS approval_decisions (
    decision_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id) ON DELETE CASCADE,
    proposal_id UUID NOT NULL REFERENCES proposed_events(proposal_id) ON DELETE CASCADE,
    
    -- The decision
    decision VARCHAR(50) NOT NULL,  -- approved, rejected, regenerated
    
    -- If rejected, why? (optional player input)
    rejection_reason TEXT,
    
    -- If regenerated, what was the new proposal?
    regenerated_to UUID REFERENCES proposed_events(proposal_id),
    
    -- Timing
    decision_time_ms INTEGER,  -- How long player took to decide
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Aggregate approval stats for tuning
CREATE TABLE IF NOT EXISTS approval_stats (
    stat_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    session_id UUID NOT NULL REFERENCES sessions(session_id) ON DELETE CASCADE,
    
    -- Aggregated over time
    total_proposed INTEGER DEFAULT 0,
    total_approved INTEGER DEFAULT 0,
    total_rejected INTEGER DEFAULT 0,
    total_regenerated INTEGER DEFAULT 0,
    
    -- By category
    positive_approved INTEGER DEFAULT 0,
    positive_rejected INTEGER DEFAULT 0,
    negative_approved INTEGER DEFAULT 0,
    negative_rejected INTEGER DEFAULT 0,
    neutral_approved INTEGER DEFAULT 0,
    neutral_rejected INTEGER DEFAULT 0,
    
    -- For adaptive generation
    avg_decision_time_ms INTEGER,
    
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT unique_stats_per_session UNIQUE(session_id)
);

-- Index for approval history
CREATE INDEX IF NOT EXISTS idx_approval_decisions_tick 
    ON approval_decisions(tick_id);

CREATE INDEX IF NOT EXISTS idx_approval_decisions_proposal 
    ON approval_decisions(proposal_id);

-- Function to record an approval decision and update stats
CREATE OR REPLACE FUNCTION record_approval_decision(
    p_tick_id UUID,
    p_proposal_id UUID,
    p_decision VARCHAR(50),
    p_rejection_reason TEXT DEFAULT NULL,
    p_decision_time_ms INTEGER DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    v_decision_id UUID;
    v_session_id UUID;
    v_category VARCHAR(50);
BEGIN
    -- Get session and category
    SELECT s.session_id, pe.category 
    INTO v_session_id, v_category
    FROM ticks t
    JOIN sessions s ON t.session_id = s.session_id
    JOIN proposed_events pe ON pe.proposal_id = p_proposal_id
    WHERE t.tick_id = p_tick_id;
    
    -- Record the decision
    INSERT INTO approval_decisions (tick_id, proposal_id, decision, rejection_reason, decision_time_ms)
    VALUES (p_tick_id, p_proposal_id, p_decision, p_rejection_reason, p_decision_time_ms)
    RETURNING decision_id INTO v_decision_id;
    
    -- Update the proposed_events status
    UPDATE proposed_events 
    SET status = p_decision
    WHERE proposal_id = p_proposal_id;
    
    -- Update stats
    INSERT INTO approval_stats (session_id, total_proposed)
    VALUES (v_session_id, 1)
    ON CONFLICT (session_id) DO UPDATE SET
        total_proposed = approval_stats.total_proposed + 1,
        total_approved = approval_stats.total_approved + CASE WHEN p_decision = 'approved' THEN 1 ELSE 0 END,
        total_rejected = approval_stats.total_rejected + CASE WHEN p_decision = 'rejected' THEN 1 ELSE 0 END,
        total_regenerated = approval_stats.total_regenerated + CASE WHEN p_decision = 'regenerated' THEN 1 ELSE 0 END,
        positive_approved = approval_stats.positive_approved + CASE WHEN p_decision = 'approved' AND v_category = 'positive' THEN 1 ELSE 0 END,
        positive_rejected = approval_stats.positive_rejected + CASE WHEN p_decision = 'rejected' AND v_category = 'positive' THEN 1 ELSE 0 END,
        negative_approved = approval_stats.negative_approved + CASE WHEN p_decision = 'approved' AND v_category = 'negative' THEN 1 ELSE 0 END,
        negative_rejected = approval_stats.negative_rejected + CASE WHEN p_decision = 'rejected' AND v_category = 'negative' THEN 1 ELSE 0 END,
        neutral_approved = approval_stats.neutral_approved + CASE WHEN p_decision = 'approved' AND v_category = 'neutral' THEN 1 ELSE 0 END,
        neutral_rejected = approval_stats.neutral_rejected + CASE WHEN p_decision = 'rejected' AND v_category = 'neutral' THEN 1 ELSE 0 END,
        updated_at = NOW();
    
    RETURN v_decision_id;
END;
$$ LANGUAGE plpgsql;

-- Register this agent's settings schema
INSERT INTO agent_registry (agent_id, display_name, description, phase, settings_schema)
VALUES (
    'player_approval',
    'Event Approval',
    'Allows player to approve or reject proposed world events',
    2,
    '{
        "parameters": [
            {
                "id": "auto_approve_positive",
                "type": "boolean",
                "default": false,
                "label": "Auto-Approve Positive Events",
                "description": "Automatically approve beneficial events without prompting",
                "ui_component": "toggle"
            },
            {
                "id": "skip_approval",
                "type": "boolean",
                "default": false,
                "label": "Skip Approval Step",
                "description": "Approve all events automatically (faster gameplay)",
                "ui_component": "toggle"
            },
            {
                "id": "show_probabilities",
                "type": "boolean",
                "default": true,
                "label": "Show Probabilities",
                "description": "Display event trigger probabilities during approval",
                "ui_component": "toggle"
            }
        ]
    }'::jsonb
)
ON CONFLICT (agent_id) DO UPDATE SET
    settings_schema = EXCLUDED.settings_schema,
    display_name = EXCLUDED.display_name;

-- ============================================
-- End Agent: Player Approval
-- ============================================

-- ============================================
-- Source: agents/outline-generator.sql
-- ============================================

-- ============================================
-- Agent: Outline Generator
-- Phase: 3
-- Description: Creates structured narrative outlines
--              with beats, branches, and NPC involvement
-- ============================================

-- Narrative outlines for each tick
CREATE TABLE IF NOT EXISTS narrative_outlines (
    outline_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id) ON DELETE CASCADE,
    
    -- The structured outline
    outline_structure JSONB NOT NULL,
    
    -- NPCs flagged as active in this outline
    active_npc_ids JSONB DEFAULT '[]',
    
    -- Complexity metrics
    beat_count INTEGER,
    branch_count INTEGER,
    
    -- Was this a fallback (simple linear outline)?
    used_fallback BOOLEAN DEFAULT FALSE,
    
    -- LLM metadata
    llm_prompt_tokens INTEGER,
    llm_completion_tokens INTEGER,
    processing_time_ms INTEGER,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Locations table (referenced by outlines and NPCs)
CREATE TABLE IF NOT EXISTS locations (
    location_id VARCHAR(100) PRIMARY KEY,
    session_id UUID NOT NULL REFERENCES sessions(session_id) ON DELETE CASCADE,
    
    -- Location details
    location_name VARCHAR(255) NOT NULL,
    location_type VARCHAR(50),  -- settlement, wilderness, building, dungeon
    description TEXT,
    
    -- Connections to other locations
    connections JSONB DEFAULT '{}',  -- {north: "location_id", south: null, ...}
    
    -- Discovery info
    discovered_tick UUID REFERENCES ticks(tick_id),
    is_known BOOLEAN DEFAULT TRUE,
    
    -- For mapping
    coordinates JSONB,  -- Optional x,y for visual map
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for finding outlines by tick
CREATE INDEX IF NOT EXISTS idx_narrative_outlines_tick 
    ON narrative_outlines(tick_id);

-- Index for finding locations by session
CREATE INDEX IF NOT EXISTS idx_locations_session 
    ON locations(session_id);

-- Register this agent's settings schema
INSERT INTO agent_registry (agent_id, display_name, description, phase, settings_schema)
VALUES (
    'outline_generator',
    'Narrative Outline Generator',
    'Creates structured outlines with beats and branches',
    3,
    '{
        "parameters": [
            {
                "id": "outline_complexity",
                "type": "enum",
                "options": ["simple", "branching", "complex"],
                "default": "branching",
                "label": "Outline Complexity",
                "description": "How elaborate the narrative structure should be",
                "ui_component": "dropdown"
            },
            {
                "id": "max_beats",
                "type": "integer",
                "min": 2,
                "max": 10,
                "default": 5,
                "step": 1,
                "label": "Maximum Beats",
                "description": "Maximum number of narrative beats per tick",
                "ui_component": "slider"
            },
            {
                "id": "pacing",
                "type": "enum",
                "options": ["slow", "normal", "fast"],
                "default": "normal",
                "label": "Narrative Pacing",
                "description": "How quickly events unfold",
                "ui_component": "dropdown"
            },
            {
                "id": "include_environmental_beats",
                "type": "boolean",
                "default": true,
                "label": "Include Environment",
                "description": "Add beats describing the environment and atmosphere",
                "ui_component": "toggle"
            }
        ]
    }'::jsonb
)
ON CONFLICT (agent_id) DO UPDATE SET
    settings_schema = EXCLUDED.settings_schema,
    display_name = EXCLUDED.display_name;

-- ============================================
-- End Agent: Outline Generator
-- ============================================

-- ============================================
-- Source: agents/npc-decision-maker.sql
-- ============================================

-- ============================================
-- Agent: NPC Decision Maker
-- Phase: 3
-- Description: Simulates NPC decisions and reactions
--              based on personality, goals, and relationships
-- ============================================

-- NPC identity (stable, doesn't change)
CREATE TABLE IF NOT EXISTS npcs (
    npc_id VARCHAR(100) PRIMARY KEY,
    session_id UUID NOT NULL REFERENCES sessions(session_id) ON DELETE CASCADE,
    
    -- Basic identity
    npc_name VARCHAR(255) NOT NULL,
    npc_title VARCHAR(255),  -- "the Innkeeper", "Captain of the Guard"
    
    -- Core personality matrix (stable traits)
    personality JSONB NOT NULL,
    
    -- Appearance and voice
    physical_description TEXT,
    voice_description TEXT,  -- "gruff", "melodic", "whispered"
    
    -- Background
    backstory TEXT,
    occupation VARCHAR(255),
    
    -- Is this NPC still active in the story?
    is_active BOOLEAN DEFAULT TRUE,
    
    -- When was this NPC first encountered?
    first_encountered_tick UUID REFERENCES ticks(tick_id),
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- NPC dynamic state (changes over time, event-sourced)
CREATE TABLE IF NOT EXISTS npc_state (
    state_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    npc_id VARCHAR(100) NOT NULL REFERENCES npcs(npc_id) ON DELETE CASCADE,
    tick_id UUID NOT NULL REFERENCES ticks(tick_id) ON DELETE CASCADE,
    
    -- Current location
    location_id VARCHAR(100) REFERENCES locations(location_id),
    
    -- Current goals (can change based on events)
    active_goals JSONB DEFAULT '[]',
    
    -- Relationship with player
    player_relationship JSONB DEFAULT '{}',
    
    -- Relationships with other NPCs
    npc_relationships JSONB DEFAULT '{}',
    
    -- Current emotional state
    emotional_state JSONB DEFAULT '{}',
    
    -- Last known info (what this NPC knows happened)
    known_events JSONB DEFAULT '[]',
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Only one state per NPC per tick
    CONSTRAINT unique_npc_state_per_tick UNIQUE(npc_id, tick_id)
);

-- NPC decisions made during simulation
CREATE TABLE IF NOT EXISTS npc_decisions (
    decision_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tick_id UUID NOT NULL REFERENCES ticks(tick_id) ON DELETE CASCADE,
    outline_id UUID REFERENCES narrative_outlines(outline_id),
    npc_id VARCHAR(100) NOT NULL REFERENCES npcs(npc_id),
    
    -- The decision
    decision_type VARCHAR(50),  -- action, dialogue, reaction, internal
    decision_description TEXT NOT NULL,
    
    -- What triggered this decision?
    trigger_event TEXT,  -- "player asked for room", "heard loud noise"
    
    -- Does this decision affect other NPCs?
    affects_npcs JSONB DEFAULT '[]',  -- List of npc_ids that should react
    triggers_chain BOOLEAN DEFAULT FALSE,  -- If true, spawns more NPC decisions
    
    -- Dialogue if applicable
    dialogue_text TEXT,
    dialogue_tone VARCHAR(50),  -- friendly, suspicious, angry, etc.
    
    -- Was this a fallback (NPC takes no action)?
    used_fallback BOOLEAN DEFAULT FALSE,
    
    -- Order within tick (for chained decisions)
    decision_sequence INTEGER DEFAULT 1,
    parent_decision_id UUID REFERENCES npc_decisions(decision_id),
    
    -- LLM metadata
    llm_prompt_tokens INTEGER,
    llm_completion_tokens INTEGER,
    processing_time_ms INTEGER,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for NPC queries
CREATE INDEX IF NOT EXISTS idx_npcs_session 
    ON npcs(session_id);

CREATE INDEX IF NOT EXISTS idx_npcs_active 
    ON npcs(session_id) WHERE is_active = TRUE;

CREATE INDEX IF NOT EXISTS idx_npc_state_npc 
    ON npc_state(npc_id, tick_id DESC);

CREATE INDEX IF NOT EXISTS idx_npc_state_location 
    ON npc_state(location_id);

CREATE INDEX IF NOT EXISTS idx_npc_decisions_tick 
    ON npc_decisions(tick_id, decision_sequence);

CREATE INDEX IF NOT EXISTS idx_npc_decisions_npc 
    ON npc_decisions(npc_id);

-- Function to get current NPC state (latest for each NPC on active branch)
CREATE OR REPLACE FUNCTION get_current_npc_state(p_session_id UUID)
RETURNS TABLE (
    npc_id VARCHAR(100),
    npc_name VARCHAR(255),
    location_id VARCHAR(100),
    active_goals JSONB,
    player_relationship JSONB,
    emotional_state JSONB
) AS $$
    WITH active_branch AS (
        SELECT branch_id FROM branches 
        WHERE session_id = p_session_id AND is_active = TRUE
        LIMIT 1
    ),
    latest_ticks AS (
        SELECT DISTINCT ON (ns.npc_id) 
            ns.npc_id,
            ns.location_id,
            ns.active_goals,
            ns.player_relationship,
            ns.emotional_state
        FROM npc_state ns
        JOIN ticks t ON ns.tick_id = t.tick_id
        JOIN active_branch ab ON t.branch_id = ab.branch_id
        ORDER BY ns.npc_id, t.tick_number DESC
    )
    SELECT 
        n.npc_id,
        n.npc_name,
        lt.location_id,
        lt.active_goals,
        lt.player_relationship,
        lt.emotional_state
    FROM npcs n
    JOIN latest_ticks lt ON n.npc_id = lt.npc_id
    WHERE n.session_id = p_session_id AND n.is_active = TRUE;
$$ LANGUAGE SQL STABLE;

-- Register this agent's settings schema
INSERT INTO agent_registry (agent_id, display_name, description, phase, settings_schema)
VALUES (
    'npc_decision_maker',
    'NPC Decision Maker',
    'Simulates NPC decisions based on personality and goals',
    3,
    '{
        "parameters": [
            {
                "id": "max_npcs_per_scene",
                "type": "integer",
                "min": 1,
                "max": 10,
                "default": 2,
                "step": 1,
                "label": "Max NPCs Per Scene",
                "description": "Maximum number of NPCs that can make decisions per tick",
                "ui_component": "slider"
            },
            {
                "id": "max_decision_chain",
                "type": "integer",
                "min": 1,
                "max": 10,
                "default": 5,
                "step": 1,
                "label": "Max Decision Chain",
                "description": "Maximum NPC reactions that can chain from one action",
                "ui_component": "slider"
            },
            {
                "id": "decision_depth",
                "type": "enum",
                "options": ["shallow", "normal", "deep"],
                "default": "normal",
                "label": "Decision Depth",
                "description": "How thoroughly NPCs consider their options",
                "ui_component": "dropdown"
            },
            {
                "id": "include_internal_monologue",
                "type": "boolean",
                "default": false,
                "label": "Show NPC Thoughts",
                "description": "Include NPC internal reasoning in output (for debugging)",
                "ui_component": "toggle"
            },
            {
                "id": "relationship_volatility",
                "type": "float",
                "min": 0.1,
                "max": 2.0,
                "default": 1.0,
                "step": 0.1,
                "label": "Relationship Volatility",
                "description": "How quickly NPC relationships change (1.0 = normal)",
                "ui_component": "slider"
            }
        ]
    }'::jsonb
)
ON CONFLICT (agent_id) DO UPDATE SET
    settings_schema = EXCLUDED.settings_schema,
    display_name = EXCLUDED.display_name;

-- ============================================
-- End Agent: NPC Decision Maker
-- ============================================

